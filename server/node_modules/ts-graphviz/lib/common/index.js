/** @hidden */
function isForwardRefNode(object) {
  return typeof object === 'object' && object !== null && typeof object.id === 'string';
}
/** @hidden */
function isNodeModel(object) {
  return typeof object === 'object' && object !== null && object.$$type === 'Node' && typeof object.id === 'string';
}
/** @hidden */
function isNodeRef(node) {
  return isNodeModel(node) || isForwardRefNode(node);
}
/** @hidden */
function isNodeRefLike(node) {
  return typeof node === 'string' || isNodeRef(node);
}
/** @hidden */
function isNodeRefGroupLike(target) {
  return Array.isArray(target) && target.every(isNodeRefLike);
}
/** @hidden */
function isCompass(c) {
  return ['n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw', 'c'].includes(c);
}
/** @hidden */
function toNodeRef(target) {
  if (isNodeRef(target)) {
    return target;
  }
  const [id, port, compass] = target.split(':');
  if (isCompass(compass)) {
    return { id, port, compass };
  }
  return { id, port };
}
/** @hidden */
function toNodeRefGroup(targets) {
  if (targets.length < 2 && (isNodeRefLike(targets[0]) && isNodeRefLike(targets[1])) === false) {
    throw Error('EdgeTargets must have at least 2 elements.');
  }
  return targets.map((t) => toNodeRef(t));
}

/**
 * @group Models Context
 * @alpha
 */
const RootModelsContext = Object.seal({
  // NOTE: RootModelsContext is also initialized after the model class is declared in the 'core/index.js' module.
  Graph: null,
  Digraph: null,
  Subgraph: null,
  Node: null,
  Edge: null,
});
/**
 * @group Models Context
 * @alpha
 */
function createModelsContext(models) {
  return Object.assign(Object.seal(Object.assign({}, RootModelsContext)), models);
}

export {
  RootModelsContext,
  createModelsContext,
  isCompass,
  isForwardRefNode,
  isNodeModel,
  isNodeRef,
  isNodeRefGroupLike,
  isNodeRefLike,
  toNodeRef,
  toNodeRefGroup,
};
